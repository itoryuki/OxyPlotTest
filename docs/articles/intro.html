<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>WPF/XAML&#12391;&#24115;&#31080;&#12398;&#12487;&#12470;&#12452;&#12531;&#12539;&#21360;&#21047;&#12434;&#34892;&#12358; </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="WPF/XAML&#12391;&#24115;&#31080;&#12398;&#12487;&#12470;&#12452;&#12531;&#12539;&#21360;&#21047;&#12434;&#34892;&#12358; ">
    <meta name="generator" content="docfx 2.5.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="wpfxamlで帳票のデザイン印刷を行う" sourcefile="articles/intro.md" sourcestartlinenumber="1" sourceendlinenumber="1">WPF/XAMLで帳票のデザイン・印刷を行う</h1>
              
<p sourcefile="articles/intro.md" sourcestartlinenumber="3" sourceendlinenumber="3">※これは <a href="http://qiita.com/advent-calendar/2016/xaml" sourcefile="articles/intro.md" sourcestartlinenumber="3" sourceendlinenumber="3">XAML Advent Calendar 2016</a> の25日目の記事です。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="5" sourceendlinenumber="5">WPF/XAML を使って帳票のデザインから印刷までやってみたという話です。ソースコードが GitHub にありますので、それと同様にやればできます。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="7" sourceendlinenumber="7"><a href="https://github.com/vain0/VainZero.WpfReportPrinting" sourcefile="articles/intro.md" sourcestartlinenumber="7" sourceendlinenumber="7">vain0/VainZero.WpfReportPrinting: WPFで帳票を作成するサンプル</a></p>
<h2 id="要約" sourcefile="articles/intro.md" sourcestartlinenumber="9" sourceendlinenumber="9">要約</h2>
<ul sourcefile="articles/intro.md" sourcestartlinenumber="10" sourceendlinenumber="12">
<li sourcefile="articles/intro.md" sourcestartlinenumber="10" sourceendlinenumber="10">XAML というマークアップ言語で帳票のデザインから印刷までできれば、たくさんの利点がある。</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="11" sourceendlinenumber="11">WPF アプリケーションで帳票のプレビューや印刷を行うサンプルを作った。</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="12" sourceendlinenumber="12">ページネーションが大変だったけどなんとかなった。</li>
</ul>
<h2 id="前提知識" sourcefile="articles/intro.md" sourcestartlinenumber="14" sourceendlinenumber="14">前提知識</h2>
<p sourcefile="articles/intro.md" sourcestartlinenumber="15" sourceendlinenumber="15">XAML、WPF について簡単に説明します。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="17" sourceendlinenumber="17">XAML とは、GUIアプリケーションの外観を記述するマークアップ言語です。WEB 系の人には「HTML+CSS みたいなもの」といえばイメージしやすいのではないでしょうか。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="19" sourceendlinenumber="19">WPF とは、XAML と .NET 言語 (C# など) を用いて、Windows PC 用のネイティヴ アプリケーションを作るためのフレームワークです。XAML は WPF 以外でも使いますが、筆者は WPF しかやったことがないので、ひとまず本稿のターゲットは WPF のみとします。</p>
<h2 id="利点" sourcefile="articles/intro.md" sourcestartlinenumber="21" sourceendlinenumber="21">利点</h2>
<p sourcefile="articles/intro.md" sourcestartlinenumber="22" sourceendlinenumber="22">WPF/XAML で帳票を作ることにはいくつかの利点があります。</p>
<ul sourcefile="articles/intro.md" sourcestartlinenumber="24" sourceendlinenumber="35">
<li sourcefile="articles/intro.md" sourcestartlinenumber="24" sourceendlinenumber="25"><strong>無料</strong><ul sourcefile="articles/intro.md" sourcestartlinenumber="25" sourceendlinenumber="25">
<li sourcefile="articles/intro.md" sourcestartlinenumber="25" sourceendlinenumber="25">WPFは Visual Studio (無料) をインストールすれば無料で使えます。商用利用する場合は、Visual Studio の有償ライセンスを購入することで、やはりWPFを無料で使えます。</li>
</ul>
</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="26" sourceendlinenumber="28"><strong>学習コストの削減</strong><ul sourcefile="articles/intro.md" sourcestartlinenumber="27" sourceendlinenumber="28">
<li sourcefile="articles/intro.md" sourcestartlinenumber="27" sourceendlinenumber="27">本稿と先述のソースコードをご覧いただければ、みなさんはWPFの知識だけで帳票のデザインから印刷まで行えるようになります。すなわち、帳票フレームワークに習熟するコストを省略できるわけです。</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="28" sourceendlinenumber="28">特に、帳票フレームワーク固有のデザイナーではなく、Visual Studio の高機能なXAMLデザイナーを利用して、プレビューを見ながらデザインを行える、というのも大きな利点です。これについては、参考リンクのブログ記事が詳しいです。</li>
</ul>
</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="29" sourceendlinenumber="30"><strong>プレビューの容易さ</strong><ul sourcefile="articles/intro.md" sourcestartlinenumber="30" sourceendlinenumber="30">
<li sourcefile="articles/intro.md" sourcestartlinenumber="30" sourceendlinenumber="30">詳しくは後述しますが、帳票をXAMLで作ることで、プレビューはほぼ完璧にできます。プレビュー機能もWPFで簡単に実装でき、メインのアプリケーションとシームレスに繋がります。</li>
</ul>
</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="31" sourceendlinenumber="32"><strong>ビューモデルの流用</strong><ul sourcefile="articles/intro.md" sourcestartlinenumber="32" sourceendlinenumber="32">
<li sourcefile="articles/intro.md" sourcestartlinenumber="32" sourceendlinenumber="32">帳票として印刷するデータ (GUIオブジェクト) の背景となるデータ構造として、WPFアプリケーションにあるものをそのまま使えることがあります。例えば、ユーザーが画面上の入力フォームにデータを記入し、それと等価な帳票を印刷する、といった場合です。</li>
</ul>
</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="33" sourceendlinenumber="35"><strong>XAML本来の利点</strong>――拡張性、可変レイアウト、など<ul sourcefile="articles/intro.md" sourcestartlinenumber="34" sourceendlinenumber="35">
<li sourcefile="articles/intro.md" sourcestartlinenumber="34" sourceendlinenumber="34">XAMLの売りとして、あらゆる要素の外観を完全にカスタマイズできる、というのがあります。これは帳票の用途にも役立つでしょう。実際、今回のサンプルでもスタイル機能をふんだんに活用しています。</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="35" sourceendlinenumber="35">ウィンドウサイズを意識することなくウィンドウをデザインできるのと同様に、用紙サイズを意識することなく帳票を作れます。</li>
</ul>
</li>
</ul>
<h2 id="簡単な帳票" sourcefile="articles/intro.md" sourcestartlinenumber="37" sourceendlinenumber="37">簡単な帳票</h2>
<p sourcefile="articles/intro.md" sourcestartlinenumber="38" sourceendlinenumber="38">まずは簡単な帳票を例に挙げて、印刷する方法まで一通り解説します。簡単な帳票とは、タイトルがどーんとあって、日付が右寄せで、あとは本文という感じです。まずはプレビュー画面のスクリーンショットをご覧ください。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="40" sourceendlinenumber="40"><img src="../images/intro/HelloWorldReportScreenshot.png" alt="簡単な帳票のプレビュー画面" sourcefile="articles/intro.md" sourcestartlinenumber="40" sourceendlinenumber="40"></p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="42" sourceendlinenumber="42">ビューモデルと XAML は次のようになっています。UI要素はプレビュー用と印刷用の2つ (以上) をインスタンス化する必要があるので、 DataTemplate の形で定義しています。</p>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="44" sourceendlinenumber="50"><code class="lang-csharp">// 印刷するページに対応するビューモデル。
// データをXAML側に埋め込んでしまったので中身がない。
public sealed class HelloWorldPageViewModel
{
}
</code></pre><pre sourcefile="articles/intro.md" sourcestartlinenumber="52" sourceendlinenumber="66"><code class="lang-xml">&lt;!--
    上記のビューモデルの表示方法を定義するテンプレート。
    Window.Resources プロパティの下に配置する。
--&gt;
&lt;DataTemplate DataType=&quot;{x:Type local:HelloWorldPageViewModel}&quot;&gt;
    &lt;Grid Margin=&quot;30&quot;&gt;
        &lt;StackPanel&gt;
            &lt;TextBlock HorizontalAlignment=&quot;Center&quot; FontSize=&quot;30&quot; Text=&quot;ハローワールド&quot; /&gt;
            &lt;TextBlock HorizontalAlignment=&quot;Right&quot; Text=&quot;2007/08/31&quot; /&gt;
            &lt;TextBlock Text=&quot;Hello, world!&quot; /&gt;
        &lt;/StackPanel&gt;
    &lt;/Grid&gt;
&lt;/DataTemplate&gt;
</code></pre><h3 id="プレビュー" sourcefile="articles/intro.md" sourcestartlinenumber="68" sourceendlinenumber="68">プレビュー</h3>
<p sourcefile="articles/intro.md" sourcestartlinenumber="69" sourceendlinenumber="69">帳票のデザインが終わったので、次はプレビューです。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="71" sourceendlinenumber="71">プレビューは、簡単にいえば、上に書いた XAML を「紙っぽいパネル」に載せるだけです。紙っぽさの演出についてはソースコードを参照してください。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="73" sourceendlinenumber="73">ここで重要なのは紙のサイズ (A4 とか) です。というのも、ページネーションや文章の折り返しなどが用紙サイズに依存してしまうため、プレビュー時点で用紙サイズを決定しておくのが無難です。(もちろんプレビューをしないというのも1つの手です。)</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="75" sourceendlinenumber="75">用紙サイズ (mm 単位) から要素のサイズを換算するには、dpi を知る必要がありますが、ここで嬉しいお知らせがあります。後述するように、印刷時にはUI要素を FixedDocument というクラスの子孫要素に配置するのですが、FixedDocument の中身は 96dpi で固定されます。すなわち、FixedDocument の中身 (印刷するデータ) を 96dpi 決め打ちで作成しておけば、その FixedDocument を 600dpi のレーザープリンターに送信しても、同じ見栄えのものが印刷されるようになっています。 (参考: <a href="https://msdn.microsoft.com/ja-jp/library/ms748388%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" sourcefile="articles/intro.md" sourcestartlinenumber="75" sourceendlinenumber="75">WPF のドキュメント</a>)</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="77" sourceendlinenumber="77">要するに、印刷するデータは 96dpi で作ればよいわけです。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="79" sourceendlinenumber="79">例えば A4 (縦) は、ISO 規格で 210mm×297mm と決まっており、1 inch = 25.40 mm 、1 inch = 96 pixel で換算すれば 793.70×1122.52 となります。このサイズで作った紙っぽいパネルにページの中身を配置すれば、実際に印刷されるのと同じ見栄えのプレビューを表示できます。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="81" sourceendlinenumber="81">次は印刷です。</p>
<h3 id="プリンターの選択" sourcefile="articles/intro.md" sourcestartlinenumber="83" sourceendlinenumber="83">プリンターの選択</h3>
<p sourcefile="articles/intro.md" sourcestartlinenumber="84" sourceendlinenumber="84">どのプリンターで印刷するかは、ユーザーに選択させる方法と、プログラム側で指定する方法の2通りがあります。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="86" sourceendlinenumber="86">ユーザーに選択させる場合は、 <code>System.Windows.Controls</code> 名前空間の <code>PrintDialog</code> クラスを使います。(参考: <a href="https://msdn.microsoft.com/ja-jp/library/system.windows.controls.printdialog%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" sourcefile="articles/intro.md" sourcestartlinenumber="86" sourceendlinenumber="86">PrintDialog クラス (System.Windows.Controls)</a>)</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="88" sourceendlinenumber="88">なお、プレビュー画面で選択された用紙サイズを印刷ダイアログの初期設定値にする方法は <del>時間が足りず調べられていません</del> 読者の演習課題とします。</p>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="90" sourceendlinenumber="105"><code class="lang-csharp">using System.Windows.Controls;

{
    var printDialog = new PrintDialog();
    var result = printDialog.ShowDialog();
    if (!result.HasValue || !result.Value)
    {
        // 印刷ダイアログがキャンセルされた。
        return;
    }

    // 後の工程で使用する。
    var queue = printDialog.PrintQueue;
}
</code></pre><p sourcefile="articles/intro.md" sourcestartlinenumber="107" sourceendlinenumber="107">プログラム側で指定する場合は、プリントサーバーというのを使用するようです。詳しくは読者の演習課題とします。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="109" sourceendlinenumber="109">ここでは、コンピューター自身を表すサーバー (localhost みたいなもの) である <code>LocalPrintServer</code> から、デフォルトのプリンターを指定する方法をとります。</p>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="111" sourceendlinenumber="126"><code class="lang-csharp">// System.Printing を参照に追加する必要があります。
using System.Printing;

public void Print(Size pageSize)
{
    var printServer = new LocalPrintServer();

    // 既定のプリンターを表す PrintQueue を取得する。
    var queue = printServer.DefaultPrintQueue;

    // プレビュー画面で用紙サイズを選択させる場合は、用紙サイズを設定しておく。
    var ticket = queue.PrintTicket;
    ticket.PageMediaSize = new PageMediaSize(pageSize.Width, pageSize.Height);;
}
</code></pre><h3 id="fixeddocument-の生成" sourcefile="articles/intro.md" sourcestartlinenumber="128" sourceendlinenumber="128">FixedDocument の生成</h3>
<p sourcefile="articles/intro.md" sourcestartlinenumber="129" sourceendlinenumber="129">先述の通り、印刷するデータを持つ FixedDocument のインスタンスを用意します。この作業は再利用可能な形式にしてあります。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="131" sourceendlinenumber="131">まず「印刷するデータを複数のページに分割する」機能 (ページネーション) を提供するインターフェイスを定義しておきます。<code>IPaginatable</code> と呼びましょう。</p>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="133" sourceendlinenumber="144"><code class="lang-csharp">using System.Windows;

public interface IPaginatable
{
    /// &lt;summary&gt;
    /// ページのサイズを受け取って、オブジェクトのリストを返す。
    /// リストに含まれる各オブジェクトは、それぞれ1つのページの中身を表す。
    /// &lt;/summary&gt;
    IReadOnlyList&lt;object&gt; Paginate(Size pageSize);
}
</code></pre><p sourcefile="articles/intro.md" sourcestartlinenumber="146" sourceendlinenumber="146">いま例にとっているハローワールド帳票では、常に1つのページになりますので、Paginate メソッドは1つのオブジェクトを返せばよいわけです。次のようになります。 [^ireport]</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="148" sourceendlinenumber="148">[^ireport]: GitHub においてあるソースコードでは、HelloWorldReport は IPaginatable だけでなく、IPaginatable を拡張する IReport というインターフェイスを実装していますが、それはサンプルの都合です。あまり気にしなくてかまいません。</p>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="150" sourceendlinenumber="165"><code class="lang-csharp">public sealed class HelloWorldReport
    : IPaginatable
{
    IReadOnlyList&lt;object&gt; Pages { get; } =
        new object[]
        {
            new HelloWorldPageViewModel(),
        };

    public IReadOnlyList&lt;object&gt; Paginate(Size size)
    {
        return Pages;
    }
}
</code></pre><p sourcefile="articles/intro.md" sourcestartlinenumber="167" sourceendlinenumber="167">あとは次の拡張メソッドを呼ぶだけです。</p>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="169" sourceendlinenumber="208"><code class="lang-csharp">public static class PaginatableExtension
{
    public static FixedDocument
        ToFixedDocument(this IPaginatable paginatable, Size pageSize)
    {
        var document = new FixedDocument();

        foreach (var content in paginatable.Paginate(pageSize))
        {
            var presenter =
                new ContentPresenter()
                {
                    Content = content,
                    Width = pageSize.Width,
                    Height = pageSize.Height,
                };

            var page =
                new FixedPage()
                {
                    Width = pageSize.Width,
                    Height = pageSize.Height,
                };
            page.Children.Add(presenter);

            // この3つを行わないと DataGrid がページ全体に展開せず、潰れた状態になる。
            // これらが実際に何をするかは余裕があったら調べたい。
            page.Measure(pageSize);
            page.Arrange(new Rect(new Point(0, 0), pageSize));
            page.UpdateLayout();

            var pageContent = new PageContent() { Child = page };
            document.Pages.Add(pageContent);
        }

        return document;
    }
}
</code></pre><p sourcefile="articles/intro.md" sourcestartlinenumber="210" sourceendlinenumber="210">このメソッドは、Paginate メソッドが返したリストの各要素につき、それを固定サイズの ContentPresenter に入れて、それを FixedPage に入れて、それを PageContent に入れて、それを FixedDocument に入れる、という感じです。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="212" sourceendlinenumber="212">こうして FixedDocument を手に入れました。</p>
<h3 id="プリンターへの送信" sourcefile="articles/intro.md" sourcestartlinenumber="214" sourceendlinenumber="214">プリンターへの送信</h3>
<p sourcefile="articles/intro.md" sourcestartlinenumber="215" sourceendlinenumber="215">最後に、この FixedDocument を、選択されたプリンターに送信すれば完了です。</p>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="217" sourceendlinenumber="225"><code class="lang-csharp">// System.Printing の参照を追加する必要があります。
using System.Printing;

{
    var writer = PrintQueue.CreateXpsDocumentWriter(queue);
    writer.Write(document);
}
</code></pre><p sourcefile="articles/intro.md" sourcestartlinenumber="227" sourceendlinenumber="227">できました。</p>
<h2 id="複雑なの帳票" sourcefile="articles/intro.md" sourcestartlinenumber="229" sourceendlinenumber="229">複雑なの帳票</h2>
<p sourcefile="articles/intro.md" sourcestartlinenumber="230" sourceendlinenumber="230">次に複数ページの帳票、すなわちページネーションの方法を解説します。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="232" sourceendlinenumber="232">まずはプレビュー画面のスクリーンショットをごらんください。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="234" sourceendlinenumber="234"><img src="../images/intro/OrderFormScreenshot.png" alt="ページネーションを含む帳票のスクリーンショット" sourcefile="articles/intro.md" sourcestartlinenumber="234" sourceendlinenumber="234"></p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="236" sourceendlinenumber="236">XAML は結構な分量なので省略します。表の部分には、スタイルをガチガチに決めた DataGrid を使用しています。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="238" sourceendlinenumber="238">簡単な帳票との差は、Paginate メソッドの実装だけです。</p>
<h3 id="paginate" sourcefile="articles/intro.md" sourcestartlinenumber="240" sourceendlinenumber="240">Paginate</h3>
<p sourcefile="articles/intro.md" sourcestartlinenumber="241" sourceendlinenumber="241">ここでは実際に DataGrid をインスタンス化することでページネーションを行います。(というか、それ以外にうまい方法があるのでしょうか。)</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="243" sourceendlinenumber="243">おおまかな手順は次の通りです。</p>
<ol sourcefile="articles/intro.md" sourcestartlinenumber="245" sourceendlinenumber="247">
<li sourcefile="articles/intro.md" sourcestartlinenumber="245" sourceendlinenumber="245">すべての行のデータを持った DataGrid を生成する。</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="246" sourceendlinenumber="246">「スクロールなしで見えている行の数」を数えて、その範囲の行からなるページを生成する。</li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="247" sourceendlinenumber="247">1ページ分スクロールして、また「見えている行の数」を数える。繰り返し。</li>
</ol>
<p sourcefile="articles/intro.md" sourcestartlinenumber="249" sourceendlinenumber="249">実際のソースコードはやや長いので、最初に張ったリンクから見てもらえればと思います。(OrderForm.cs の中にあります。)</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="251" sourceendlinenumber="251">注意点は2つあります。</p>
<ul sourcefile="articles/intro.md" sourcestartlinenumber="253" sourceendlinenumber="253">
<li sourcefile="articles/intro.md" sourcestartlinenumber="253" sourceendlinenumber="253">DataGrid を初期化した後、画面サイズに合わせてレイアウトを再計算させる必要がある。</li>
</ul>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="255" sourceendlinenumber="270"><code class="lang-csharp">    // ページネーションを行うために、実際に DataGrid を生成する。
    var preview = new OrderFormPage(Header, Items);
    var presenter =
        new ContentPresenter()
        {
            Content = preview,
            Width = size.Width,
            Height = size.Height,
        };

    // DataGrid のレイアウトを計算させる魔法のコード
    presenter.Measure(size);
    presenter.Arrange(new Rect(new Point(0, 0), size));
    presenter.UpdateLayout();
</code></pre><p sourcefile="articles/intro.md" sourcestartlinenumber="272" sourceendlinenumber="272">Measure, Arrange, UpdateLayout の3つを起動することで、DataGrid が余白に合わせて適切なサイズに広がります。</p>
<ul sourcefile="articles/intro.md" sourcestartlinenumber="274" sourceendlinenumber="274">
<li sourcefile="articles/intro.md" sourcestartlinenumber="274" sourceendlinenumber="274">「見えている行の数」の代わりに、「見える行数の最大値」である <code>ScrollViewer.ViewportHeight</code> が使用できる。(「見えている行の数」を厳密に取得する方法 <del>が分からなかった……</del> は読者の演習課題)</li>
</ul>
<p sourcefile="articles/intro.md" sourcestartlinenumber="276" sourceendlinenumber="276">DataGrid のデフォルトの見た目では、中身をスクロールできるように ScrollViewer が配置されていて、「見える行数の最大値」のような情報を取得するには、それのプロパティを見ればいいわけです。問題となるのは、ScrollViewer のインスタンスをどう捕まえるかなのですが、VisualTree を辿るのが1つの方法です。これについては、参考リンクにあるブログ記事を参照してください。(あるいはソースコードを参照。)</p>
<h2 id="サンプルプログラムの概略" sourcefile="articles/intro.md" sourcestartlinenumber="278" sourceendlinenumber="278">サンプルプログラムの概略</h2>
<p sourcefile="articles/intro.md" sourcestartlinenumber="279" sourceendlinenumber="279">必殺「ソースコードをごらんください」を思ったより使ってしまったので、サンプルプログラムの概略について説明します。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="281" sourceendlinenumber="282">念のためリンクを再掲します:
<a href="https://github.com/vain0/VainZero.WpfReportPrinting" sourcefile="articles/intro.md" sourcestartlinenumber="282" sourceendlinenumber="282">vain0/VainZero.WpfReportPrinting: WPFで帳票を作成するサンプル</a></p>
<h3 id="ソリューション構成" sourcefile="articles/intro.md" sourcestartlinenumber="284" sourceendlinenumber="284">ソリューション構成</h3>
<p sourcefile="articles/intro.md" sourcestartlinenumber="285" sourceendlinenumber="285">ソリューションは <code>VainZero.WpfReportPrinting.Core</code> と <code>VainZero.WpfReportPrinting.Demo</code> の2つのプロジェクトからなります。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="287" sourceendlinenumber="287">前者 (<code>.Core</code>) は再利用可能な部品で、そのまま流用できるようになっています。中身は、先述の <code>IPaginatable</code> とその拡張メソッド、および VisualTree がらみの小さな拡張メソッドです。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="289" sourceendlinenumber="289">後者 (<code>.Demo</code>) は、帳票のプレビューと印刷の機能を持つアプリケーションです。印刷時のオプションは多数ありますので、これをベースにして、必要によりカスタマイズしながら作るのがよいと思います。</p>
<h3 id="使い方" sourcefile="articles/intro.md" sourcestartlinenumber="291" sourceendlinenumber="291">使い方</h3>
<p sourcefile="articles/intro.md" sourcestartlinenumber="292" sourceendlinenumber="292">まず使い方から説明します。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="294" sourceendlinenumber="294"><code>.Demo</code> アプリを実行すると、ウィンドウが1つ表示されます。まずは左側のペインにあるリストボックスで、プレビューする帳票の種類を選びます。種類というのは、本稿で挙げた「簡単な帳票」(ハローワールド)と「複雑な帳票」(注文書)の2つです。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="296" sourceendlinenumber="296">右側ペインの上部には、コンボボックスと印刷ボタンがあります。左端のコンボボックスでは、紙のサイズを指定します。紙のサイズが変わるたびにページネーションが再計算されるのがミソです。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="298" sourceendlinenumber="298">右側ペインの残りの部分はプレビューです。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="300" sourceendlinenumber="300">印刷ボタンを押すと、デフォルトのプリンターで印刷されます。(印刷ダイアログは表示されません。)</p>
<h3 id="実装" sourcefile="articles/intro.md" sourcestartlinenumber="302" sourceendlinenumber="302">実装</h3>
<p sourcefile="articles/intro.md" sourcestartlinenumber="303" sourceendlinenumber="303">メインウィンドウ (MainWindow.xaml) の中身は、1つの <code>SampleReportPreviewer</code> クラス (を DataTemplate で表示したもの) であり、これは先述の通り「左側ペイン」(帳票セレクター/<code>Reports.ReportSelector</code>)と「右側ペイン」(プレビューアー/<code>Previewing.Previewer</code>)からなります。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="305" sourceendlinenumber="305"><code>ReportSelector</code> は本当にただの <code>ListBox</code> ですが、2つ注意するところがあります。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="307" sourceendlinenumber="307">1点は、<a href="https://github.com/runceel/ReactiveProperty" sourcefile="articles/intro.md" sourcestartlinenumber="307" sourceendlinenumber="307">ReactiveProperty</a> というクラスです。これは平たくいえば次のようなクラスです (※実際の定義ではありません)。</p>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="309" sourceendlinenumber="326"><code class="lang-csharp">public class ReactiveProperty&lt;T&gt;
    : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler PropertyChanged;

    private T _value;
    public T Value
    {
        get { return _value; }
        set
        {
            _value = value;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Value)));
        }
    }
}
</code></pre><p sourcefile="articles/intro.md" sourcestartlinenumber="328" sourceendlinenumber="328">値をこれでラップしておくことで、 <code>INotifyPropertyChanged</code> の実装をいちいち手書きする (あるいは継承する) 必要がなくなる、という寸法ですね。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="330" sourceendlinenumber="330">もう1点は、リストボックスの各要素の型である <code>IReport</code> です。注釈にも書きましたが、これは <code>IPaginatable</code> に1つのプロパティを加えただけの拡張インターフェイスです。そのプロパティ (<code>ReportName</code>) というのは、単にリストボックスの各項目に表示するための名前(文字列)です。そのため、<code>IPaginatable</code> と同じだと思ってかまわないでしょう。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="332" sourceendlinenumber="332">さて、プレビューアーにあるコンボボックス2つも同様のことに気をつければ問題ないはずです。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="334" sourceendlinenumber="334"><code>Previewer</code> のコンストラクターにある <a href="https://github.com/vain0/VainZero.WpfReportPrinting/blob/v1.1.0/VainZero.WpfReportPrinting.Demo/Previewing/Previewer.cs#L42" sourcefile="articles/intro.md" sourcestartlinenumber="334" sourceendlinenumber="334">この式</a> は、Rx を知らないと読み解けないかもしれません。</p>
<pre sourcefile="articles/intro.md" sourcestartlinenumber="336" sourceendlinenumber="343"><code class="lang-csharp">            Pages =
                Report.CombineLatest(
                    MediaSizeSelector.SelectedSize,
                    (r, pageSize) =&gt; r.Paginate(pageSize)
                )
                .ToReadOnlyReactiveProperty();
</code></pre><p sourcefile="articles/intro.md" sourcestartlinenumber="345" sourceendlinenumber="345">これは平たくいえば「<code>Report</code>, <code>MediaSizeSelector.SelectedSize</code> の最新の値を <code>r</code>, <code>pageSize</code> とするとき、 <code>r.Paginate(pageSize)</code> の結果を <code>Pages</code> の値とする」という意味です。もう少し手続き的にいえば、まず <code>Report</code> と <code>`MediaSizeSelector.SelectedSize</code> の値をとってきて、 <code>Paginate</code> します。加えて、そのどちらかのプロパティが変更されるたび (リストボックスやコンボボックスの選択要素が変わるたび)、ページネーションを再試行します。</p>
<p sourcefile="articles/intro.md" sourcestartlinenumber="347" sourceendlinenumber="347">最後に印刷ボタンですが、これは押されたとき、<code>Previewer.PrintCommand</code>→<code>Previewer.Print</code> を経由して <code>Printer.Print</code> まで行き、そこからは前半で述べた感じです。FixedDocument を作って、デフォルトのプリンターを取得して、ページサイズを指定して、印刷。</p>
<h2 id="おわりに" sourcefile="articles/intro.md" sourcestartlinenumber="349" sourceendlinenumber="349">おわりに</h2>
<p sourcefile="articles/intro.md" sourcestartlinenumber="350" sourceendlinenumber="350">いかがでしたでしょうか。不明点などあればコメントないし <a href="https://github.com/vain0/VainZero.WpfReportPrinting/issues" sourcefile="articles/intro.md" sourcestartlinenumber="350" sourceendlinenumber="350">イシュー</a> をお願いします。</p>
<h2 id="参考リンク" sourcefile="articles/intro.md" sourcestartlinenumber="352" sourceendlinenumber="352">参考リンク</h2>
<h3 id="帳票関連" sourcefile="articles/intro.md" sourcestartlinenumber="353" sourceendlinenumber="353">帳票関連</h3>
<ul sourcefile="articles/intro.md" sourcestartlinenumber="354" sourceendlinenumber="354">
<li sourcefile="articles/intro.md" sourcestartlinenumber="354" sourceendlinenumber="354"><a href="http://koty.hatenablog.com/entry/2013/12/15/122352" sourcefile="articles/intro.md" sourcestartlinenumber="354" sourceendlinenumber="354">WPFを帳票フレームワークとして使う - @kotyのブログ</a></li>
</ul>
<h3 id="wpf関連" sourcefile="articles/intro.md" sourcestartlinenumber="356" sourceendlinenumber="356">WPF関連</h3>
<ul sourcefile="articles/intro.md" sourcestartlinenumber="357" sourceendlinenumber="358">
<li sourcefile="articles/intro.md" sourcestartlinenumber="357" sourceendlinenumber="357"><a href="http://stackoverflow.com/a/7601504/6419575" sourcefile="articles/intro.md" sourcestartlinenumber="357" sourceendlinenumber="357">c# - Check visible rows in a WPF DataGrid - Stack Overflow</a></li>
<li sourcefile="articles/intro.md" sourcestartlinenumber="358" sourceendlinenumber="358"><a href="http://blog.xin9le.net/entry/2013/10/29/222336" sourcefile="articles/intro.md" sourcestartlinenumber="358" sourceendlinenumber="358">VisualTreeの子孫要素を取得する - xin9le.net</a></li>
</ul>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/vain0/VainZero.WpfReportPrinting/blob/x/document/articles/intro.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2016 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
